\documentclass[12pt]{article} % Document font size and equations flushed left

\usepackage[english]{babel} % Specify a different language here - english by default


\usepackage{graphicx,xcolor,comment}
\usepackage[margin=2cm]{geometry}
\usepackage{comment}
\usepackage{enumerate}

\reversemarginpar

\renewcommand{\thesection}{\Alph{section}}

\newcommand{\arrm}{}
\newcommand{\arrb}{}

%\newcommand{\arrm}{\marginpar{\textcolor{red}{$\Longrightarrow$}}}
%\newcommand{\arrb}{\marginpar{\textcolor{blue}{$\Longrightarrow$}}}


\setlength{\columnsep}{0.55cm} % Distance between the two columns of text
\setlength{\fboxrule}{0.75pt} % Width of the border around the abstract

%----------------------------------------------------------------------------------------
%   COLORS
%----------------------------------------------------------------------------------------

\definecolor{color1}{RGB}{0,0,90} % Color of the article title and sections
\definecolor{color2}{RGB}{0,20,20} % Color of the boxes behind the abstract and headings


\usepackage{hyperref} % Required for hyperlinks
\hypersetup{hidelinks,colorlinks,breaklinks=true,urlcolor=color2,citecolor=color1,linkcolor=color1,bookmarksopen=false,pdftitle={Title},pdfauthor={Author}}

\newcommand{\defexerc} { \newcounter{numa}}
\defexerc

\newcommand{\nn} {\addtocounter{numa}{1}\arabic{numa}}

\newcommand{\alabel}[2]{\newcounter{#1}\setcounter{#1}{#2}}

\DeclareRobustCommand{\resp}{\vspace*{1ex}\noindent\textbf{Answer (\nn): }}
%\DeclareRobustCommand{\q}[1]{\vspace*{1ex} \noindent \textbf{Reviewer: } {{\itshape #1}} }
\DeclareRobustCommand{\q}[1]{\vspace*{1ex} \noindent \textbf{Reviewer: } \begin{em}#1\end{em} }

\title{Reply to All Reviewers of the Article
``The Cyan Object-Oriented Language''} % Article title

\author{José de Oliveira Guimarães}
%\textsuperscript{1}*} % Authors
%\affiliation{\textsuperscript{1}\textit{Department of Biology, University of Examples, London, United Kingdom}} % Author affiliation
%\affiliation{*\textbf{Corresponding author}: john@smith.com} % Corresponding author

%\Keywords{} % Keywords - if you don't want any simply remove all the text between the curly brackets

\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}

%----------------------------------------------------------------------------------------

\begin{document}

%\abstract{This is a replay to all three reviewers of the article
%``The Cyan Language Metaobject Protocol''}


\flushbottom % Makes all text pages the same height

%\maketitle % Print the title and abstract box


\noindent {\Large Reply to All Reviewers of the Article
``The Cyan Object-Oriented Language''}


\vspace*{3ex}
This article was previously submitted to ``Computer Languages''. In the following text, the reviewers' comments are responded to. Only reviewer 2 had comments. I sincerely thank the previous reviewers who took the time to review the article.

The sections of this document  are numbered by letters to differentiate them from the article sections.

\section{Comments to All Reviewers} 

Comments from the Editors and Reviewers:


Reviewer 1: I reviewed papers on Cyan several times in a couple of years.
This version is probably one of the best, but it still has several issues, some of which are crucial and prevent the publication unless addressed/fixed.

First of all, I do not understand the intended contribution of the paper: in its current shape, the paper is a manual of Cyan, which, as I have already stressed in the past, is quite complex (due to its features, which are not necessarily useful), despite what the author says.
I understand that Cyan is an old language that has not yet been published, but that is not a justification for accepting such a paper in its current shape.
There are "related work" sections in all the sections describing the features of the language, but that is not enough to make the paper appealing.

Just this sentence in the abstract "The language offers innovative features that support each of these constructs. The goal is to increase developer's productivity without sacrificing security." is not enough.
I'd advise the author to avoid such claims, which are really hard to prove (e.g., speaking of productivity without an IDE - which is now a future work, at least - is really dangerous).
I wouldn't even say that it offers innovative features: those features are already known from other works in the literature and are based on already established language constructs.

Moreover, a few parts of the descriptions of the features are not really clear (see below for details).

In general, this does not look like a research paper due to the writing style and, as already said above, the contents.

DETAILED COMMENTS:

- "A class, even when
considered an object, does not have the fields and methods it describes."
That is a very strange sentence.

- first code snippet on page 2: it should be introduced appropriately.

- "ident is called a method keyword or just a keyword." isn't "just a keyword" a bit misleading in general?

- in general, please use the LaTeX listings package (after properly creating a new configuration for the language Cyan)

- "they can only be assigned to in their declarations or in constructors.
Fields declared without var or let are read-only."
so "let" is redundant?

- "by the keyword shared" which then corresponds to "static" in mainstream languages? If so, why not say that?

- "The compiler adds bodies that throw exceptions when called (they should not
be called)."
should not or ensured never to be called?

- "Hereafter, superprototypes that are not interfaces are called
superprototypes."
It sounds like a redundant sentence.

- "There is a top-level prototype called Any that is inherited (directly or indirectly) by all prototypes,"
like Object in Java? If so, say that.

- "For every init and init: constructor of a prototype T, the compiler adds methods..."
So the programmer cannot define "new" methods, right?

- "The selector of a unary method is its identifier."
what is the concept of "selector" useful for?
If it's not useful, don't mention it.

- "Because the name of a method uses only its keywords and the number of parameters associated
with each keyword, the compiler can differentiate between two methods without examining any type."
strange and obscure sentence.

- "Cyan supports compile-time objects called metaobjects that can change the compilation process by tem-
porarily adding code (the source files are not altered)..."
adding code where?

- " In the source code, a metaobject is linked to an annotation attached to a declaration
(prototype, method, field), statement, or other syntactic elements. In the following example, immutable,
init, and restrictTo are annotations."
So, in the code snippet, where is the metaobject?
"linked to an annotation" or corresponds to the annotation?

- " It is important to stress that, for each annotation, there is an
associated metaobject, and vice versa."
So they are the same thing? See above.

- "A dashed line indicates that the bottom type is a
subtype of the top type, although no inheritance relationship exists between them."
not even an implicit one?

- "Type Dyn is the supertype of all prototypes and even of all Java classes when mixing Cyan and Java code."
Strange sentence... it looks like existing Java classes are turned into subclasses of "Dyn"...

- " This restriction is intended to make unions easier to read."
PLEASE!!! The restriction is to make the implementation easier!!!
Union types are meant to be commutative, as they've always been, and there's no problem with that.

- "There are two special cases of this rule..." (in union and intersection types)
NO! They are not special cases; they're just other rules defining subtyping on union and intersection types.
By the way, DO CITE the papers from which this subtyping has been taken.
(I hope the author did not re-invent the wheel in that respect)

- "The cast test is done in the textual order
of the case clauses."
So we can write a dead-code? Does the compiler checks that?

- Section "Method Overloading".
Listing 2 makes perfect sense if you know Java rules, and there's nothing strange about that.
In general, overloading and overriding should not be confused and mixed as the author does in the paper.
In general, using static information for overloading is crucial to have a safe language.
I'm not sure the "solution" applied in Cyan is safe or clearer.
It looks like "dynamic overloading", right?
If so, there are crucial aspects to consider like avoiding ambiguities at compile time and provide a very efficient implementation of method selection. It looks like method selection is done by walking the hierarchy at runtime: that's not efficient.
Concerning "Item (e) cannot be
avoided. However, this issue is not serious because the language does not support multiple inheritance,..."
So (e) is actually avoided, isn't it?
"Cyan
tries to give precedence to runtime information in such a way that the developer is never in doubt if the
method to be called for a message passing will be decided based on runtime types of objects or compile-time
types. It is always based on runtime types."
This sounds very dangerous from a type safety point of view...
Otherwise, the sentence is not clear.

- "The compiler will do all possible type checkings and insert code
to do the checks that can only be done at runtime."
Please introduce the subsequent code snippet.

- "Gradual typing"
The text from "One of the goals of gradual typing is to make it easy" to the end of "Gradual typing" is rather incomprehensible.

- "obj `messageAsString: args"
it's the first time I see "`"; is that a special syntax?
Is there a missing closing "`".

- "stats" please call them "statements"

- " Keyword return is used to return a value from a method. It cannot be used inside an
anonymous function. A function returns a value by supplying an expression after ^ as in the code"
why introduce another syntax instead of "return"?!
Please don't say it is to make things easier because it's just confusing to have another syntax.

- "The code of anonymous functions cannot be reused because they are literal objects. "
So, an anonymous function cannot be assigned to a variable or passed as an argument?
If so, it is very limiting.
Why then have another concept for anonymous functions like "context objects"?!
It looks like making things more complex...

- "...which suggests that this field is some kind of reference. It is, ..."
You're not writing fiction, please avoid such a style in a research paper.

- "Even its source code is available!"
please avoid exclamation marks in a research paper.

- " The meaning of all other statements of the language remains the same
when Dyn is replaced by a prototype, and vice versa. This can be checked by a tedious process of examining
all statements (not done here)."
Are you referring to a formal proof here when referring to a "tedious" process?
Tedious or not, you should be formally certain of your assertions.

- "To our knowledge, context objects are not directly related to any construction of other languages. "
Because they look useless and complicated (even due to the name) since the concept of "lambda expression" has been providing the same features for ages, also in OOP (what you describe as context objects look very similar to Java lambda expressions).

- " Instead of using an anonymous function in one place, the developer can put its code in the eval:
method of a context object reused multiple times. Even the access to local variables can be abstracted in
the context object. "
obscure sentence!

- "Safe Expression"
why "safe"?

- "One problem with object initialization is self leakage, which is to pass it as a parameter to a method
inside the constructor."
Please be explicit about "it", it might not be immediately clear what "it" refers to.

- "Cyan provides mechanisms that prevent most problems associated with unsafe object initialization."
So it uses the previously mentioned solutions? Or something else?
It also looks like serious problems happen very rarely, so why spend so much text on that?

- Section " Limitations for Prototypes"
In general, the section is nearly incomprehensible (starting from the title).
I have the feeling that its contents can be summarized in a few sentence (from the very little I understand in this section)

- Section " Generic Prototypes"
is not obscure like the previous one, but it is not even clear.
(on a side note, Listing 5 should give an idea of what "Box" is meant for... it looks like a "Wrapper").
The concept of "identifier" appears here, and later as "lowercase identifier"; are they the same thing?
The use of identifier as argument for generic prototype looks strange; can it be related to C++ template specialization?

- "Cyan itself does
not support concepts, which are implemented through metaobject concept."
So it does support it, why "not support"?

- the whole paragraph
"Generic prototypes in Cyan benefit from metaprogramming. Metaobjects are used for dealing with a
varying number of parameters and generating code. This allows the creation of type-specific code for each
instantiation. As an example, a metaobject creates methods for the Tuple prototype based on its real type
arguments. Another interesting example is the createArrayMethods annotation that is attached to generic
prototype Array. At compile time, the metaobject associated with this annotation adds some methods to
the prototype, such as hashCode, asString:, and sort (if the type parameter defines a method <=>)."
looks like out of context in this part.

- " The Exception Handling System"
The exception handling system in Cyan is rather complicated.
If I understand it correctly, what the author describes as innovative can be easily done in Java by using object delegation in catch blocks.
If not, then the section does not help understand this mechanism.

- "Conclusions"
The section starts abruptly.
Typically you start summarizing the contribution of the paper, though, as I said in the beginning, the contribution is not clear.
The novelties and improvements described in this section (already stated in the previous sections) are doubtful, as I have already said above.
In particular, as I said above, the "In relation to method overloading, the compile-time types of message arguments are never
considered when choosing a method at runtime." looks dangerous from a typing point of view unless I misunderstand the sentence.

- "A Language Server Protocol (LSP) defines a bridge between an IDE and
.... Another alternative would be to use Xtext"
Xtext supports the creation of LSP, so it is not an alternative.

\section{Comments to Reviewer 2}


\begin{comment}
Reviewer 2: ** The Ideas and Main Claims

The paper makes the following main claims (in the abstract):

1. "Cyan is a statically-typed prototype-based language that supports":
a. "non-nullable types,"
b. "partially safe object initialization"
c. "gradual typing,"
d. "method overloading,"
e. "anonymous functions"
f. "an object-oriented exception handling system"
g. "generic types with concepts, and"
h. "meta-programming at compile-time through a Metaobject Protocol."
2. The goal of the language "is to increase developer's productivity
without sacrificing security."

** Comments on the Ideas and Main Claims

The paper supports these claims. For claim 1, Cyan is certainly a
statically typed prototype-based language and it supports features
a-h, all of which are discussed in the paper.

For claim 2, there is only a rationale, but no experiments. The
rationale mostly talks about security (avoiding errors, especially
common ones), and the productivity goal is mostly left to the reader's
understanding.

The language is interesting in that it makes several tradeoffs that
future programming language designers might learn from. For example,
overloading in Cyan always agrees with the dynamic lookup of a most
specific method, due to the rules for overloading (see p. 10). In
particular, there are several tradeoffs made to allow compile-time
checking, at the expense of expressiveness. In addition, the
interaction between the Metaobject Protocol and the language features
is interesting.

** Other General Comments and Suggestions
\end{comment}

\q{In many places the paper talks about the compiler; I would suggest
that these should refer to the language, ...
}

\resp Changed everywhere except in some specific cases in which it makes sense reference the compiler.


\q{The exception handling mechanism was not described clearly enough to
determine if all exceptions must be handled in each method, which was
the impression I received. That should be made clear and if all
exceptions must be handled statically in a method, then the rationale
for this should be given.}

\resp Corrected. In the beginning of the section on the exception handling system, it was added ``Cyan supports only unchecked exceptions: there is no syntax for a method to declare the exceptions it may throw". 

\q{
I would have liked to have a link to more extensive examples written
in the language, and such a link would be useful to mention towards
the beginning of the paper.}

\resp Done. 

https://cyan-lang.org/cyancode-for-the-cyan-object-oriented-language-submitted-article/

* SPECIFIC COMMENTS

P. 1, section 1, "Interest in programming language design has
increased in recent decades." I am not so sure. Is there any evidence
for this that can be cited?

P. 2, lines 44-45, It would be helpful to show the code for Person's
init method in a figure in the paper. It does not seem to be in
Listing 1.

P. 3, line 54, Change "a message passing" to "message passing" in two
places.

P. 4, line 69, I suggest omitting the sentence "Let us explain that."

P. 4, line 83, Maybe change "top-level" to "most general"?

P. 4, line 94, change "a new or new method" to "a new or new: method".

P. 6, line 141, change "A prototype that does not explicitly inherit
from any prototype inherits from Any." to "A prototype (aside from
Nil) that does not explicitly inherit from any prototype inherits from
Any." Otherwise the statement contradicts Figure 1.

P. 7, lines 175-176, The claim "Cyan is a
Nil-safe language; runtime errors never happen because of Nil and
prototypes." seems somewhat vague. It is not clear what it means for a
runtime error to "happen because of Nil". Can this be made more
precise?

P. 8, line 195, I suggest adding, at the end of the line: "In the
following example" and then uncapitalizing the "Which" on line 197
that follows the example.

P. 10, line 257, here is one place that "compiler" could possibly be
replaced by a reference to the "Cyan language".

P. 11, line 296, change "/* stats */" to "/* stmts */" as "stats" is
often used as an abbreviation for "statistics" but "stmts" would be
understood as an abbreviation for "statements".

P. 13, line 358, I wonder if it would be clearer to change "Fields are
initialized..." to "Instance fields are initialized..."?

P. 13, line 360, Perhaps change "should" to "must"?

P. 14, line 364, Perhaps change "A prototype may not define any
constructors if ..." to "A prototype need not define any constructors
if ..."?

P. 16, line 414, I think that item g in the list that ends at the top
of this page is redundant and could be omitted.

P. 16, line 427, It might be better to change "... the
accessOnlySharedFields annotation will be used in a few cases." to
"... the accessOnlySharedFields annotation will be used in only a few
cases."

P. 16, section 5, lines 440-443, doesn't the problem of the infinite
regression of metaclasses also occur for metaobjects? I don't see
how switching from classes to prototype objects helps in this
respect. So, I suggest either omitting this or explaining it further.
For example on p. 17, lines 456-459, it is unclear how Cyan handles
this issue (perhaps give a reference to the discussion about
initialization in the paper here?).

P. 17, line 455, it would be helpful to see the code for Planet here.

P. 20, in the section on related work, I think that the discussion of
Concepts should also mention the CLU programming language, see for
example:

Atkinson, Russell R., Barbara H. Liskov, and Robert
W. Scheifler. "Aspects of implementing CLU." In Proceedings of the
1978 annual conference, pp. 123-129. 1978.

or (better perhaps) section 4 of

Liskov, B., Snyder, A., Atkinson, R. and Schaffert, C.,
1977. Abstraction mechanisms in CLU. Communications of the ACM, 20(8),
pp.564-576.

P. 21, line 552, add CLU to the list "Rust, Swift, G, and C#".

P. 21, section 7, see the general comments above about the exception
handling mechanism. Since the types of methods do not declare
exceptions, it was unclear to me if they need to be handled statically
in Cyan. Requiring exceptions to be handled statically would be
different than most languages (CLU, Java, C++, etc.) and would be
interesting to see justified if that is the case. If exceptions can
propagate outside of methods, then how the checks mentioned in section
7 (esp. on p. 25) are handled is unclear, as the handlers would be
dynamically scoped (as usual).

P. 26, At this point it is still unclear to me what a "context object"
(mentioned on line 666) is or if exceptions can propagate outside of
methods.






\end{comment}

\label{all}

First of all, here are all of the important (and clickable) links about the language:

\begin{enumerate}[(i)]
\item The Cyan Language manual, the description of the Metaobject Protocol, and some articles: \url{http://cyan-lang.org/docs}.

\item The compiler with the libraries, including the source code and tests: \url{http://cyan-lang.org/downloads}.

\item A list of 90 metaobjects: \url{http://cyan-lang.org/metaobject-examples}

\item A list of Codegs: \url{http://cyan-lang.org/codegs-1}.

\item The online compiler: \url{http://ec2-18-116-30-135.us-east-2.compute.amazonaws.com}

    \noindent Unfortunately, the online compiler is limited to only one file. Therefore, it is not possible to inherit a developer-created prototype or create a generic prototype. In these cases, use the compiler.
\end{enumerate}






\section{Comments to Reviewer 2}
%\q{}

%\resp

\begin{enumerate}[(a)]

\item The reviewer wrote ``What about IDE integration? I seem to understand there's some plugins but not a real IDE?''. There is a paragraph in the conclusion talking about that. We plan to use a language server\footnote{https://microsoft.github.io/language-server-protocol} for that. Two students have volunteered to do the job.

\item The reviewer complained on the sentence ``In Java, there are several ambiguities and irregularities causing traps (J. Chan, W. Yang, J.
Huang, Traps in java, J. Syst. Softw. 72)''.
Any references to these ambiguities and irregularities were removed. They do not exist anymore in Java.

\item The language now  allows declarations like

\verb#    var Int|(Char|Person)|Any  p;#\\
\noindent in which \verb|(| and \verb|)| are used in a type union.

\item The installation of the Cyan compiler is now straightforward. One has to just download a file and execute it. The user will be guided  through  the installation.

\item The rules for subtyping were changed, as requested.

\item There are now intersection types:
\begin{verbatim}
  var Closeable & Printable ca;
\end{verbatim}

\item Exception handling is now done by a \tt{try-catch} statement, and exceptions are raised by a \tt{throw} statement. Previously, it was made by message passing. An example using the new syntax is:
\begin{verbatim}
  try
    if num == 0 {
      throw ExcDivZero
    }
    if num < 0  {
      throw ExcNegNumber(num)
    }
    share = value/num;
  catch { (: ExcDivZero e :)
     "Division by 0" println
  }
  catch { (: ExcNegNumber e :)
     Out println: (
       "Illegal negative number: " ++ (e getNumber) );
  };
\end{verbatim}

\item The subsection on overloaded methods was corrected. At the end,  the subsection explains the design decisions behind the method overloading in the language.

\item Cyan methods that do not return anything return \tt{Nil}. It was argued that this causes a loss in performance because any method has to return something. This is not true because the compiler does not really return the value \tt{Nil}.

An exception is when the code uses runtime reflection to call a method that returns \tt{Nil}. In this case, there is a test to discover the return type of the method, and the object \tt{Nil} is returned.

\end{enumerate}

\end{document}

